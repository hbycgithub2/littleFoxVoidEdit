<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Align & Distribute Test - Phaser 3</title>
    <script src="lib/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; font-family: Arial; }
        #panel { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.95); 
                 padding: 15px; border-radius: 8px; border: 2px solid #2196F3; 
                 color: #fff; max-width: 320px; max-height: 90vh; overflow-y: auto; }
        .btn { background: #2196F3; color: #fff; border: none; padding: 8px 12px; 
               margin: 3px; border-radius: 4px; cursor: pointer; font-size: 11px; }
        .btn:hover { background: #1976D2; }
        .result { margin: 5px 0; padding: 5px; border-left: 3px solid #4CAF50; }
        .pass { color: #4CAF50; }
        .fail { color: #ff5555; }
        h4 { margin: 10px 0 5px 0; color: #2196F3; }
    </style>
</head>
<body>
    <div id="panel">
        <h3 style="margin:0 0 10px 0;">ğŸ¯ å¯¹é½åˆ†å¸ƒæµ‹è¯•</h3>
        <div style="margin-bottom:10px;">
            <strong>é€‰æ‹©:</strong><br>
            <button class="btn" onclick="game.scene.scenes[0].selectAll()">å…¨é€‰(A)</button>
            <button class="btn" onclick="game.scene.scenes[0].clearSelection()">æ¸…é™¤</button>
            <button class="btn" onclick="game.scene.scenes[0].selectRandom()">éšæœº3ä¸ª</button>
        </div>
        <h4>å¯¹é½æ“ä½œ:</h4>
        <button class="btn" onclick="game.scene.scenes[0].testAlignLeft()">â†å·¦å¯¹é½(1)</button>
        <button class="btn" onclick="game.scene.scenes[0].testAlignRight()">â†’å³å¯¹é½(2)</button>
        <button class="btn" onclick="game.scene.scenes[0].testAlignCenterH()">â†”æ°´å¹³å±…ä¸­(3)</button><br>
        <button class="btn" onclick="game.scene.scenes[0].testAlignTop()">â†‘é¡¶éƒ¨å¯¹é½(4)</button>
        <button class="btn" onclick="game.scene.scenes[0].testAlignBottom()">â†“åº•éƒ¨å¯¹é½(5)</button>
        <button class="btn" onclick="game.scene.scenes[0].testAlignCenterV()">â†•å‚ç›´å±…ä¸­(6)</button>
        <h4>åˆ†å¸ƒæ“ä½œ:</h4>
        <button class="btn" onclick="game.scene.scenes[0].testDistributeH()">æ°´å¹³åˆ†å¸ƒ(7)</button>
        <button class="btn" onclick="game.scene.scenes[0].testDistributeV()">å‚ç›´åˆ†å¸ƒ(8)</button>
        <h4>ç‰¹æ®Š:</h4>
        <button class="btn" onclick="game.scene.scenes[0].testAlignCanvas()">ç”»å¸ƒå±…ä¸­(9)</button>
        <button class="btn" onclick="game.scene.scenes[0].resetPositions()">é‡ç½®ä½ç½®(R)</button>
        <h4>è‡ªåŠ¨æµ‹è¯•:</h4>
        <button class="btn" onclick="game.scene.scenes[0].runFullTest()" style="background:#4CAF50;">
            ğŸš€ è¿è¡Œå®Œæ•´æµ‹è¯•
        </button>
        <div id="results" style="margin-top:10px;"></div>
    </div>

    <script>
        class AlignTestScene extends Phaser.Scene {
            constructor() {
                super({ key: 'AlignTest' });
                this.hotspots = [];
                this.selected = [];
                this.initialPositions = [];
            }

            create() {
                this.cameras.main.setBackgroundColor('#2d2d2d');
                
                // åˆ›å»ºç½‘æ ¼èƒŒæ™¯
                this.createGrid();
                
                // åˆ›å»ºæµ‹è¯•çƒ­åŒº
                this.createHotspots();
                
                // æ˜¾ç¤ºè¯´æ˜
                this.showInstructions();
                
                // è®¾ç½®é”®ç›˜
                this.setupKeyboard();
                
                this.log('âœ“ åˆå§‹åŒ–å®Œæˆï¼Œå…± ' + this.hotspots.length + ' ä¸ªçƒ­åŒº');
            }

            createGrid() {
                const g = this.add.graphics();
                g.lineStyle(1, 0x333333, 0.5);
                for (let x = 0; x <= 800; x += 50) {
                    g.lineBetween(x, 0, x, 600);
                }
                for (let y = 0; y <= 600; y += 50) {
                    g.lineBetween(0, y, 800, y);
                }
                g.setDepth(-1);
            }

            createHotspots() {
                const positions = [
                    { x: 120, y: 100 }, { x: 280, y: 140 }, { x: 450, y: 110 },
                    { x: 600, y: 130 }, { x: 150, y: 280 }, { x: 320, y: 320 },
                    { x: 500, y: 300 }, { x: 650, y: 310 }, { x: 200, y: 480 }
                ];

                positions.forEach((pos, i) => {
                    const h = this.createHotspot(pos.x, pos.y, i + 1);
                    this.hotspots.push(h);
                    this.initialPositions.push({ x: pos.x, y: pos.y });
                });
            }

            createHotspot(x, y, id) {
                const c = this.add.container(x, y);
                
                const g = this.add.graphics();
                g.lineStyle(3, 0x00ff00, 1);
                g.strokeRect(-45, -35, 90, 70);
                c.add(g);
                
                const t = this.add.text(0, 0, id.toString(), {
                    fontSize: '18px', color: '#fff', fontStyle: 'bold'
                });
                t.setOrigin(0.5);
                c.add(t);
                
                c.setData('id', id);
                c.setData('graphics', g);
                c.setData('selected', false);
                
                g.setInteractive(
                    new Phaser.Geom.Rectangle(-45, -35, 90, 70),
                    Phaser.Geom.Rectangle.Contains
                );
                
                g.on('pointerdown', () => {
                    if (this.input.keyboard.addKey('SHIFT').isDown) {
                        this.toggleSelect(c);
                    } else {
                        this.clearSelection();
                        this.select(c);
                    }
                });
                
                return c;
            }

            toggleSelect(h) {
                if (h.getData('selected')) this.deselect(h);
                else this.select(h);
            }

            select(h) {
                h.setData('selected', true);
                this.selected.push(h);
                const g = h.getData('graphics');
                g.clear();
                g.lineStyle(5, 0xffff00, 1);
                g.strokeRect(-45, -35, 90, 70);
                g.lineStyle(3, 0x00ff00, 1);
                g.strokeRect(-47, -37, 94, 74);
            }

            deselect(h) {
                h.setData('selected', false);
                this.selected = this.selected.filter(s => s !== h);
                const g = h.getData('graphics');
                g.clear();
                g.lineStyle(3, 0x00ff00, 1);
                g.strokeRect(-45, -35, 90, 70);
            }

            clearSelection() {
                [...this.selected].forEach(h => this.deselect(h));
            }

            selectAll() {
                this.clearSelection();
                this.hotspots.forEach(h => this.select(h));
                this.log('âœ“ å·²å…¨é€‰ ' + this.hotspots.length + ' ä¸ªçƒ­åŒº');
            }

            selectRandom() {
                this.clearSelection();
                const shuffled = Phaser.Utils.Array.Shuffle([...this.hotspots]);
                for (let i = 0; i < 3 && i < shuffled.length; i++) {
                    this.select(shuffled[i]);
                }
                this.log('âœ“ éšæœºé€‰æ‹©äº† 3 ä¸ªçƒ­åŒº');
            }

            resetPositions() {
                this.hotspots.forEach((h, i) => {
                    h.x = this.initialPositions[i].x;
                    h.y = this.initialPositions[i].y;
                });
                this.log('âœ“ å·²é‡ç½®æ‰€æœ‰çƒ­åŒºä½ç½®');
            }

            showInstructions() {
                this.add.text(20, 20, [
                    'ğŸ¯ å¯¹é½åˆ†å¸ƒå®Œæ•´æµ‹è¯•',
                    'Shift+ç‚¹å‡»å¤šé€‰ | æ•°å­—é”®1-9å¿«é€Ÿæ“ä½œ | Aå…¨é€‰ | Ré‡ç½®'
                ], {
                    fontSize: '13px', color: '#fff',
                    backgroundColor: '#000', padding: { x: 10, y: 6 }
                }).setDepth(100);
            }

            setupKeyboard() {
                this.input.keyboard.on('keydown-ONE', () => this.testAlignLeft());
                this.input.keyboard.on('keydown-TWO', () => this.testAlignRight());
                this.input.keyboard.on('keydown-THREE', () => this.testAlignCenterH());
                this.input.keyboard.on('keydown-FOUR', () => this.testAlignTop());
                this.input.keyboard.on('keydown-FIVE', () => this.testAlignBottom());
                this.input.keyboard.on('keydown-SIX', () => this.testAlignCenterV());
                this.input.keyboard.on('keydown-SEVEN', () => this.testDistributeH());
                this.input.keyboard.on('keydown-EIGHT', () => this.testDistributeV());
                this.input.keyboard.on('keydown-NINE', () => this.testAlignCanvas());
                this.input.keyboard.on('keydown-A', () => this.selectAll());
                this.input.keyboard.on('keydown-R', () => this.resetPositions());
            }

            testAlignLeft() {
                if (this.selected.length < 2) {
                    this.log('âš ï¸ å·¦å¯¹é½éœ€è¦è‡³å°‘2ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const minX = Math.min(...this.selected.map(h => h.x));
                this.selected.forEach(h => h.x = minX);
                this.log('âœ“ å·¦å¯¹é½å®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testAlignRight() {
                if (this.selected.length < 2) {
                    this.log('âš ï¸ å³å¯¹é½éœ€è¦è‡³å°‘2ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const maxX = Math.max(...this.selected.map(h => h.x));
                this.selected.forEach(h => h.x = maxX);
                this.log('âœ“ å³å¯¹é½å®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testAlignCenterH() {
                if (this.selected.length < 2) {
                    this.log('âš ï¸ æ°´å¹³å±…ä¸­éœ€è¦è‡³å°‘2ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const xs = this.selected.map(h => h.x);
                const centerX = (Math.min(...xs) + Math.max(...xs)) / 2;
                this.selected.forEach(h => h.x = centerX);
                this.log('âœ“ æ°´å¹³å±…ä¸­å®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testAlignTop() {
                if (this.selected.length < 2) {
                    this.log('âš ï¸ é¡¶éƒ¨å¯¹é½éœ€è¦è‡³å°‘2ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const minY = Math.min(...this.selected.map(h => h.y));
                this.selected.forEach(h => h.y = minY);
                this.log('âœ“ é¡¶éƒ¨å¯¹é½å®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testAlignBottom() {
                if (this.selected.length < 2) {
                    this.log('âš ï¸ åº•éƒ¨å¯¹é½éœ€è¦è‡³å°‘2ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const maxY = Math.max(...this.selected.map(h => h.y));
                this.selected.forEach(h => h.y = maxY);
                this.log('âœ“ åº•éƒ¨å¯¹é½å®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testAlignCenterV() {
                if (this.selected.length < 2) {
                    this.log('âš ï¸ å‚ç›´å±…ä¸­éœ€è¦è‡³å°‘2ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const ys = this.selected.map(h => h.y);
                const centerY = (Math.min(...ys) + Math.max(...ys)) / 2;
                this.selected.forEach(h => h.y = centerY);
                this.log('âœ“ å‚ç›´å±…ä¸­å®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testDistributeH() {
                if (this.selected.length < 3) {
                    this.log('âš ï¸ æ°´å¹³åˆ†å¸ƒéœ€è¦è‡³å°‘3ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const sorted = [...this.selected].sort((a, b) => a.x - b.x);
                const minX = sorted[0].x;
                const maxX = sorted[sorted.length - 1].x;
                const spacing = (maxX - minX) / (sorted.length - 1);
                sorted.forEach((h, i) => h.x = minX + spacing * i);
                this.log('âœ“ æ°´å¹³åˆ†å¸ƒå®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testDistributeV() {
                if (this.selected.length < 3) {
                    this.log('âš ï¸ å‚ç›´åˆ†å¸ƒéœ€è¦è‡³å°‘3ä¸ªçƒ­åŒº', 'fail');
                    return;
                }
                const sorted = [...this.selected].sort((a, b) => a.y - b.y);
                const minY = sorted[0].y;
                const maxY = sorted[sorted.length - 1].y;
                const spacing = (maxY - minY) / (sorted.length - 1);
                sorted.forEach((h, i) => h.y = minY + spacing * i);
                this.log('âœ“ å‚ç›´åˆ†å¸ƒå®Œæˆ (' + this.selected.length + 'ä¸ª)', 'pass');
            }

            testAlignCanvas() {
                if (this.selected.length === 0) {
                    this.log('âš ï¸ è¯·å…ˆé€‰æ‹©çƒ­åŒº', 'fail');
                    return;
                }
                const centerX = 400, centerY = 300;
                if (this.selected.length === 1) {
                    this.selected[0].x = centerX;
                    this.selected[0].y = centerY;
                } else {
                    const xs = this.selected.map(h => h.x);
                    const ys = this.selected.map(h => h.y);
                    const offsetX = centerX - (Math.min(...xs) + Math.max(...xs)) / 2;
                    const offsetY = centerY - (Math.min(...ys) + Math.max(...ys)) / 2;
                    this.selected.forEach(h => {
                        h.x += offsetX;
                        h.y += offsetY;
                    });
                }
                this.log('âœ“ ç”»å¸ƒå±…ä¸­å®Œæˆ', 'pass');
            }

            runFullTest() {
                this.log('ğŸš€ å¼€å§‹å®Œæ•´è‡ªåŠ¨æµ‹è¯•...', 'info');
                let delay = 0;

                this.time.delayedCall(delay += 500, () => {
                    this.resetPositions();
                    this.log('ğŸ“ æµ‹è¯•1: å·¦å¯¹é½å‰3ä¸ªçƒ­åŒº');
                    this.clearSelection();
                    [0, 1, 2].forEach(i => this.select(this.hotspots[i]));
                    this.testAlignLeft();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.log('ğŸ“ æµ‹è¯•2: é¡¶éƒ¨å¯¹é½');
                    this.testAlignTop();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.log('ğŸ“ æµ‹è¯•3: æ°´å¹³åˆ†å¸ƒ');
                    this.testDistributeH();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.resetPositions();
                    this.log('ğŸ“ æµ‹è¯•4: å³å¯¹é½å3ä¸ªçƒ­åŒº');
                    this.clearSelection();
                    [6, 7, 8].forEach(i => this.select(this.hotspots[i]));
                    this.testAlignRight();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.log('ğŸ“ æµ‹è¯•5: åº•éƒ¨å¯¹é½');
                    this.testAlignBottom();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.log('ğŸ“ æµ‹è¯•6: å‚ç›´åˆ†å¸ƒ');
                    this.testDistributeV();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.resetPositions();
                    this.log('ğŸ“ æµ‹è¯•7: æ°´å¹³å±…ä¸­å¯¹é½');
                    this.clearSelection();
                    [1, 4, 7].forEach(i => this.select(this.hotspots[i]));
                    this.testAlignCenterH();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.log('ğŸ“ æµ‹è¯•8: å‚ç›´å±…ä¸­å¯¹é½');
                    this.testAlignCenterV();
                });

                this.time.delayedCall(delay += 1500, () => {
                    this.resetPositions();
                    this.log('ğŸ“ æµ‹è¯•9: ç”»å¸ƒå±…ä¸­ï¼ˆå…¨é€‰ï¼‰');
                    this.selectAll();
                    this.testAlignCanvas();
                });

                this.time.delayedCall(delay += 2000, () => {
                    this.log('ğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆï¼', 'pass');
                    this.showTestSummary();
                });
            }

            showTestSummary() {
                const summary = this.add.text(400, 300, [
                    'âœ… å¯¹é½åˆ†å¸ƒæµ‹è¯•æ€»ç»“',
                    '',
                    'âœ“ å·¦å¯¹é½ - é€šè¿‡',
                    'âœ“ å³å¯¹é½ - é€šè¿‡',
                    'âœ“ æ°´å¹³å±…ä¸­ - é€šè¿‡',
                    'âœ“ é¡¶éƒ¨å¯¹é½ - é€šè¿‡',
                    'âœ“ åº•éƒ¨å¯¹é½ - é€šè¿‡',
                    'âœ“ å‚ç›´å±…ä¸­ - é€šè¿‡',
                    'âœ“ æ°´å¹³åˆ†å¸ƒ - é€šè¿‡',
                    'âœ“ å‚ç›´åˆ†å¸ƒ - é€šè¿‡',
                    'âœ“ ç”»å¸ƒå±…ä¸­ - é€šè¿‡',
                    '',
                    'æ‰€æœ‰åŠŸèƒ½å®Œç¾è¿è¡Œï¼'
                ], {
                    fontSize: '15px', color: '#4CAF50',
                    backgroundColor: '#000', padding: { x: 20, y: 15 },
                    align: 'left'
                });
                summary.setOrigin(0.5);
                summary.setDepth(1000);
            }

            log(msg, type = 'info') {
                console.log(msg);
                const div = document.getElementById('results');
                const color = type === 'pass' ? '#4CAF50' : type === 'fail' ? '#ff5555' : '#fff';
                const entry = document.createElement('div');
                entry.className = 'result';
                entry.style.borderLeftColor = color;
                entry.style.color = color;
                entry.innerHTML = msg;
                div.insertBefore(entry, div.firstChild);
                
                // ä¿æŒæœ€å¤š10æ¡è®°å½•
                while (div.children.length > 10) {
                    div.removeChild(div.lastChild);
                }
            }
        }

        const game = new Phaser.Game({
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: document.body,
            scene: AlignTestScene
        });
    </script>
</body>
</html>
